\subsection{Разработка слоя абстракции для логики предметной области}
\label{sec:design:business}

Логика предметной области лежит в основе любого программного средства и определяет правила .

Как было указано в подразделе~\ref{sec:design:architecture}, логика предметной области приложения заключается в компоненте Model архитектуры MVVM\@.
Однако, также возможно отделить логику предметной области приложения от особенностей взаимодействия с конкретной базой данных.
Данное решение имеет следующие преимущества:
\begin{itemize}
    \item Возможность с минимальными изменениями кода поменять реализацию доступа к базе данных, что позволяет полностью отделить логику предметной области от конкретной программной платформы.
    \item В силу своей обособленности предметная логика легко поддается Unit-тестированию.
    \item Отсутствие дублирования кода упрощает поддержку и ускоряет скорость разработки.
\end{itemize}

Каждый компонент предметной области приложения должен предоставлять следующий минимальный набор классов и интерфейсов:
\begin{itemize}
    \item Класс сущности, экземпляры которого будут содержать всю значимую информацию о сущности.
    \item Service -- интерфейс, представляющий собой API для работы с данной сущностью в компоненте ViewModel.
    \item Storage -- интерфейс, через который логика предметной области может получить доступ к хранимым данным.
    Данная абстракция нужна для отсутствия зависимостей предметной логики от конкретной реализации доступа к базе данных.
\end{itemize}

Кроме того, для обеспечения целостности данных, существует необходимость выполнять несколько операций с базой данных таким образом, чтобы либо были выполнены все из них, либо ни одна.
Другими словами, необходимо предоставить возможность выполнять несколько операций в одной транзакции базы данных (транзакция базы данных не является сущностью предметной области <<Транзакция>>).
Для обеспечения данной возможности, при организации доступа к базе данных, помимо реализации интерфейсов типа Storage требуется также реализовать следующий интерфейс:
\begin{lstlisting}[style=standard]
interface StorageTransactionManager {
    // `Метод принимает блок кода для выполнения его в рамках одной`
    // `БД транзакции и возвращает результат данного блока`
    fun <R> inDbTransaction(block: () -> R): R
}
\end{lstlisting}

Необходимо учитывать, что во время доступа к базе данных могут возникать различные исключительные ситуации, например, потеря связи с БД или обычная ошибка в реализации.
Для учёта таких ситуаций, необходимо ввести собственный тип исключительных ситуаций -- StorageException.
При реализации доступа к конкретной базе данных, требуется отлавливать каждое исключение и помещать его в экземпляр StorageException для того, описываемые абстракции могли точно знать, чего ожидать.

